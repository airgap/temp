#!/bin/bash
# deploy-route.sh

if [ "$#" -ne 1 ]; then
    echo "Usage: $0 <service-name>"
    exit 1
fi

export SERVICE_NAME=$1
# Add timestamp to ensure unique image tag
export TIMESTAMP=$(date +%Y%m%d%H%M%S)
export IMAGE=registry.digitalocean.com/lyku/lyku:${SERVICE_NAME}-${TIMESTAMP}

echo "SERVICE_NAME: ${SERVICE_NAME}"
echo "Building and deploying with timestamp: ${TIMESTAMP}"

# Check for route-specific configuration in package.json
PACKAGE_JSON_FILE="apps/routes/${SERVICE_NAME}/package.json"

# Default resource values
export MEMORY_REQUEST="120Mi"
export MEMORY_LIMIT="180Mi"
export CPU_REQUEST="10m"
export CPU_LIMIT="50m"

# Check if route has custom resource configuration in package.json
if [ -f "$PACKAGE_JSON_FILE" ]; then
    # Extract resource values using jq (if available)
    if command -v jq &> /dev/null; then
        # Check if k8s.resources exists in package.json
        if [ -n "$(jq -r '.k8s.resources // empty' < "$PACKAGE_JSON_FILE")" ]; then
            echo "ğŸ“‹ Found custom k8s resource configuration in package.json"

            # Extract resource values
            if [ -n "$(jq -r '.k8s.resources.requests.memory // empty' < "$PACKAGE_JSON_FILE")" ]; then
                export MEMORY_REQUEST=$(jq -r '.k8s.resources.requests.memory' < "$PACKAGE_JSON_FILE")
            fi
            if [ -n "$(jq -r '.k8s.resources.requests.cpu // empty' < "$PACKAGE_JSON_FILE")" ]; then
                export CPU_REQUEST=$(jq -r '.k8s.resources.requests.cpu' < "$PACKAGE_JSON_FILE")
            fi
            if [ -n "$(jq -r '.k8s.resources.limits.memory // empty' < "$PACKAGE_JSON_FILE")" ]; then
                export MEMORY_LIMIT=$(jq -r '.k8s.resources.limits.memory' < "$PACKAGE_JSON_FILE")
            fi
            if [ -n "$(jq -r '.k8s.resources.limits.cpu // empty' < "$PACKAGE_JSON_FILE")" ]; then
                export CPU_LIMIT=$(jq -r '.k8s.resources.limits.cpu' < "$PACKAGE_JSON_FILE")
            fi
        fi
    else
        echo "âš ï¸  jq not found, using defaults. Install jq for custom resource configuration."
    fi
fi

echo "ğŸ”§ Using resource configuration:"
echo "   Memory Request: ${MEMORY_REQUEST}"
echo "   Memory Limit: ${MEMORY_LIMIT}"
echo "   CPU Request: ${CPU_REQUEST}"
echo "   CPU Limit: ${CPU_LIMIT}"

# Check if being called from NX (which already built and pushed)
if [ -z "$NX_TASK_TARGET_PROJECT" ]; then
    # Not from NX, do the full build process
    echo "ğŸ“¦ Building route ${SERVICE_NAME}..."
    ./scripts/build-route ${SERVICE_NAME}
    if [ $? -ne 0 ]; then
        echo "âŒ Build failed!"
        exit 1
    fi

    # Dockerize and push the route with new tag
    echo "ğŸ³ Dockerizing route ${SERVICE_NAME}..."
    docker build \
        --build-arg ROUTE_NAME=${SERVICE_NAME} \
        -f docker/templates/route.Dockerfile \
        -t registry.digitalocean.com/lyku/lyku:${SERVICE_NAME}-${TIMESTAMP} \
        .
    if [ $? -ne 0 ]; then
        echo "âŒ Docker build failed!"
        exit 1
    fi

    echo "ğŸ“¤ Pushing image to registry..."
    docker push registry.digitalocean.com/lyku/lyku:${SERVICE_NAME}-${TIMESTAMP}
    if [ $? -ne 0 ]; then
        echo "âŒ Docker push failed!"
        exit 1
    fi
else
    # Called from NX, image should already exist with non-timestamped tag
    # Tag the existing image with timestamp
    echo "ğŸ·ï¸  Tagging existing image with timestamp..."
    docker tag registry.digitalocean.com/lyku/lyku:${SERVICE_NAME} registry.digitalocean.com/lyku/lyku:${SERVICE_NAME}-${TIMESTAMP}
    docker push registry.digitalocean.com/lyku/lyku:${SERVICE_NAME}-${TIMESTAMP}
fi

configLocation=~/lyk8s-kubeconfig.yaml
export config=--kubeconfig=${configLocation}
export DEPLOYMENT_NAME=lyku-${SERVICE_NAME}

echo "ğŸš€ Deploying ${SERVICE_NAME} with image ${IMAGE}"

# Check if the deployment exists in the lyku namespace
if kubectl get deployment ${DEPLOYMENT_NAME} -n lyku ${config} >/dev/null 2>&1; then
    echo "ğŸ“ Updating existing deployment ${DEPLOYMENT_NAME}"
    # Apply the manifest with the new configuration
    envsubst < k8s/micro.yaml | kubectl apply -f - ${config}
    # Force a rollout to ensure pods are recreated with new image
    kubectl rollout restart deployment/${DEPLOYMENT_NAME} -n lyku ${config}
    echo "âœ… Deployment ${DEPLOYMENT_NAME} updated with new image"
else
    echo "ğŸ†• Creating new deployment ${DEPLOYMENT_NAME}"
    # Apply the micro.yaml to create the deployment if it does not exist
    envsubst < k8s/micro.yaml | kubectl apply -f - ${config}
    echo "âœ… Deployment ${DEPLOYMENT_NAME} created"
fi

echo ""
echo "âœ… Deployment complete!"
echo "ğŸ“Š To create a monitoring dashboard, run: ./scripts/graph-route $SERVICE_NAME"
